import{r as I,E as S}from"./iframe-EZlCblT_.js";const _=I.createContext(void 0),Ie=()=>{const e=I.useContext(_);if(!e)throw new Error("MUI X: useGridRootProps should only be used inside the DataGrid, DataGridPro or DataGridPremium component.");return e},O=I.createContext(void 0);function Pe(){const e=I.useContext(O);if(e===void 0)throw new Error(["MUI X: Could not find the Data Grid context.","It looks like you rendered your component outside of a DataGrid, DataGridPro or DataGridPremium parent component.","This can also happen if you are bundling multiple versions of the Data Grid."].join(`
`));return e}var b=Symbol("NOT_FOUND");function F(e,t=`expected a function, instead received ${typeof e}`){if(typeof e!="function")throw new TypeError(t)}function W(e,t=`expected an object, instead received ${typeof e}`){if(typeof e!="object")throw new TypeError(t)}function B(e,t="expected all items to be functions, instead received the following types: "){if(!e.every(o=>typeof o=="function")){const o=e.map(r=>typeof r=="function"?`function ${r.name||"unnamed"}()`:typeof r).join(", ");throw new TypeError(`${t}[${o}]`)}}var E=e=>Array.isArray(e)?e:[e];function $(e){const t=Array.isArray(e[0])?e[0]:e;return B(t,"createSelector expects all input-selectors to be functions, but received the following types: "),t}function q(e,t){const o=[],{length:r}=e;for(let c=0;c<r;c++)o.push(e[c].apply(null,t));return o}function V(e){let t;return{get(o){return t&&e(t.key,o)?t.value:b},put(o,r){t={key:o,value:r}},getEntries(){return t?[t]:[]},clear(){t=void 0}}}function K(e,t){let o=[];function r(a){const f=o.findIndex(p=>t(a,p.key));if(f>-1){const p=o[f];return f>0&&(o.splice(f,1),o.unshift(p)),p.value}return b}function c(a,f){r(a)===b&&(o.unshift({key:a,value:f}),o.length>e&&o.pop())}function s(){return o}function d(){o=[]}return{get:r,put:c,getEntries:s,clear:d}}var X=(e,t)=>e===t;function H(e){return function(o,r){if(o===null||r===null||o.length!==r.length)return!1;const{length:c}=o;for(let s=0;s<c;s++)if(!e(o[s],r[s]))return!1;return!0}}function J(e,t){const o=typeof t=="object"?t:{equalityCheck:t},{equalityCheck:r=X,maxSize:c=1,resultEqualityCheck:s}=o,d=H(r);let a=0;const f=c<=1?V(d):K(c,d);function p(){let n=f.get(arguments);if(n===b){if(n=e.apply(null,arguments),a++,s){const u=f.getEntries().find(l=>s(l.value,n));u&&(n=u.value,a!==0&&a--)}f.put(arguments,n)}return n}return p.clearCache=()=>{f.clear(),p.resetResultsCount()},p.resultsCount=()=>a,p.resetResultsCount=()=>{a=0},p}var Q=class{constructor(e){this.value=e}deref(){return this.value}},Y=typeof WeakRef<"u"?WeakRef:Q,Z=0,N=1;function T(){return{s:Z,v:void 0,o:null,p:null}}function x(e,t={}){let o=T();const{resultEqualityCheck:r}=t;let c,s=0;function d(){let a=o;const{length:f}=arguments;for(let i=0,u=f;i<u;i++){const l=arguments[i];if(typeof l=="function"||typeof l=="object"&&l!==null){let m=a.o;m===null&&(a.o=m=new WeakMap);const g=m.get(l);g===void 0?(a=T(),m.set(l,a)):a=g}else{let m=a.p;m===null&&(a.p=m=new Map);const g=m.get(l);g===void 0?(a=T(),m.set(l,a)):a=g}}const p=a;let n;if(a.s===N)n=a.v;else if(n=e.apply(null,arguments),s++,r){const i=c?.deref?.()??c;i!=null&&r(i,n)&&(n=i,s!==0&&s--),c=typeof n=="object"&&n!==null||typeof n=="function"?new Y(n):n}return p.s=N,p.v=n,n}return d.clearCache=()=>{o=T(),d.resetResultsCount()},d.resultsCount=()=>s,d.resetResultsCount=()=>{s=0},d}function G(e,...t){const o=typeof e=="function"?{memoize:e,memoizeOptions:t}:e,r=(...c)=>{let s=0,d=0,a,f={},p=c.pop();typeof p=="object"&&(f=p,p=c.pop()),F(p,`createSelector expects an output function after the inputs, but received: [${typeof p}]`);const n={...o,...f},{memoize:i,memoizeOptions:u=[],argsMemoize:l=x,argsMemoizeOptions:m=[]}=n,g=E(u),h=E(m),y=$(c),v=i(function(){return s++,p.apply(null,arguments)},...g),C=l(function(){d++;const j=q(y,arguments);return a=v.apply(null,j),a},...h);return Object.assign(C,{resultFunc:p,memoizedResultFunc:v,dependencies:y,dependencyRecomputations:()=>d,resetDependencyRecomputations:()=>{d=0},lastResult:()=>a,recomputations:()=>s,resetRecomputations:()=>{s=0},memoize:i,argsMemoize:l})};return Object.assign(r,{withTypes:()=>r}),r}var ee=G(x),te=Object.assign((e,t=ee)=>{W(e,`createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof e}`);const o=Object.keys(e),r=o.map(s=>e[s]);return t(r,(...s)=>s.reduce((d,a,f)=>(d[o[f]]=a,d),{}))},{withTypes:()=>te});const oe=G({memoize:J,memoizeOptions:{maxSize:1,equalityCheck:Object.is}}),ne=(e,t,o,r,c,s,d,a,...f)=>{if(f.length>0)throw new Error("Unsupported number of selectors");let p;if(e&&t&&o&&r&&c&&s&&d&&a)p=(n,i,u,l)=>{const m=e(n,i,u,l),g=t(n,i,u,l),h=o(n,i,u,l),y=r(n,i,u,l),v=c(n,i,u,l),C=s(n,i,u,l),P=d(n,i,u,l);return a(m,g,h,y,v,C,P,i,u,l)};else if(e&&t&&o&&r&&c&&s&&d)p=(n,i,u,l)=>{const m=e(n,i,u,l),g=t(n,i,u,l),h=o(n,i,u,l),y=r(n,i,u,l),v=c(n,i,u,l),C=s(n,i,u,l);return d(m,g,h,y,v,C,i,u,l)};else if(e&&t&&o&&r&&c&&s)p=(n,i,u,l)=>{const m=e(n,i,u,l),g=t(n,i,u,l),h=o(n,i,u,l),y=r(n,i,u,l),v=c(n,i,u,l);return s(m,g,h,y,v,i,u,l)};else if(e&&t&&o&&r&&c)p=(n,i,u,l)=>{const m=e(n,i,u,l),g=t(n,i,u,l),h=o(n,i,u,l),y=r(n,i,u,l);return c(m,g,h,y,i,u,l)};else if(e&&t&&o&&r)p=(n,i,u,l)=>{const m=e(n,i,u,l),g=t(n,i,u,l),h=o(n,i,u,l);return r(m,g,h,i,u,l)};else if(e&&t&&o)p=(n,i,u,l)=>{const m=e(n,i,u,l),g=t(n,i,u,l);return o(m,g,i,u,l)};else if(e&&t)p=(n,i,u,l)=>{const m=e(n,i,u,l);return t(m,i,u,l)};else if(e)p=e;else throw new Error("Missing arguments");return p},re=e=>(...t)=>{const o=new WeakMap;let r=1;const c=t[t.length-1],s=t.length-1||1,d=Math.max(c.length-s,0);if(d>3)throw new Error("Unsupported number of arguments");return(f,p,n,i)=>{let u=f.__cacheKey__;u||(u={id:r},f.__cacheKey__=u,r+=1);let l=o.get(u);if(!l){const m=t.length===1?[y=>y,c]:t;let g=t;const h=[void 0,void 0,void 0];switch(d){case 0:break;case 1:{g=[...m.slice(0,-1),()=>h[0],c];break}case 2:{g=[...m.slice(0,-1),()=>h[0],()=>h[1],c];break}case 3:{g=[...m.slice(0,-1),()=>h[0],()=>h[1],()=>h[2],c];break}default:throw new Error("Unsupported number of arguments")}l=oe(...g),l.selectorArgs=h,o.set(u,l)}switch(d){case 3:l.selectorArgs[2]=i;case 2:l.selectorArgs[1]=n;case 1:l.selectorArgs[0]=p}switch(d){case 0:return l(f);case 1:return l(f,p);case 2:return l(f,p,n);case 3:return l(f,p,n,i);default:throw new Error("unreachable")}}},se=re(),w=(...e)=>{const t=ne(...e);return(r,c,s,d)=>t(A(r),c,s,d)},k=(...e)=>{const t=se(...e);return(r,c,s,d)=>t(A(r),c,s,d)},ce=e=>(t,o)=>e(A(t),o);function A(e){return"current"in e?e.current.state:e}const R=ce(e=>e.rows),ke=w(R,e=>e.totalRowCount),Ae=w(R,e=>e.loading),Me=w(R,e=>e.totalTopLevelRowCount),U=w(R,e=>e.dataRowIdToModelLookup);w(U,(e,t)=>e[t]);const ie=w(R,e=>e.tree),L=w(ie,(e,t)=>e[t]),De=w(R,e=>e.groupsToFetch),Ee=w(R,e=>e.groupingName),Ne=w(R,e=>e.treeDepths),xe=k(R,e=>{const t=Object.entries(e.treeDepths);return t.length===0?1:(t.filter(([,o])=>o>0).map(([o])=>Number(o)).sort((o,r)=>r-o)[0]??0)+1}),le=w(R,e=>e.dataRowIds),Ge=k(le,U,(e,t)=>e.reduce((o,r)=>(t[r]&&o.push(t[r]),o),[])),ue=w(R,e=>e?.additionalRowGroups),ae=k(ue,e=>{const t=e?.pinnedRows;return{bottom:t?.bottom?.map(o=>({id:o.id,model:o.model??{}}))??[],top:t?.top?.map(o=>({id:o.id,model:o.model??{}}))??[]}}),Ue=w(ae,e=>(e?.top?.length||0)+(e?.bottom?.length||0)),z="auto-generated-group-node-root",de=Symbol("mui.id_autogenerated"),Le=()=>({type:"group",id:z,depth:-1,groupingField:null,groupingKey:null,isAutoGenerated:!0,children:[],childrenFromPath:{},childrenExpanded:!0,parent:null});function pe(e,t,o="A row was provided without id in the rows prop:"){if(e==null)throw new Error(["MUI X: The Data Grid component requires all rows to have a unique `id` property.","Alternatively, you can use the `getRowId` prop to specify a custom id for each row.",o,JSON.stringify(t)].join(`
`))}const M=(e,t,o)=>{const r=t?t(e):e.id;return pe(r,e,o),r},ze=(e,t,o)=>{const r=t.field;if(!t||!t.valueGetter)return e[r];const c=e[t.field];return t.valueGetter(c,e,t,o)},je=({rows:e,getRowId:t,loading:o,rowCount:r})=>{const c={type:"full",rows:[]},s={};for(let d=0;d<e.length;d+=1){const a=e[d],f=M(a,t);s[f]=a,c.rows.push(f)}return{rowsBeforePartialUpdates:e,loadingPropBeforePartialUpdates:o,rowCountPropBeforePartialUpdates:r,updates:c,dataRowIdToModelLookup:s}},fe=({tree:e,rowCountProp:t=0})=>{const o=e[z];return Math.max(t,o.children.length+(o.footerId==null?0:1))},_e=({apiRef:e,rowCountProp:t=0,loadingProp:o,previousTree:r,previousTreeDepths:c,previousGroupsToFetch:s})=>{const d=e.current.caches.rows,{tree:a,treeDepths:f,dataRowIds:p,groupingName:n,groupsToFetch:i=[]}=e.current.applyStrategyProcessor("rowTreeCreation",{previousTree:r,previousTreeDepths:c,updates:d.updates,dataRowIdToModelLookup:d.dataRowIdToModelLookup,previousGroupsToFetch:s}),u=e.current.unstable_applyPipeProcessors("hydrateRows",{tree:a,treeDepths:f,dataRowIds:p,dataRowIdToModelLookup:d.dataRowIdToModelLookup});return e.current.caches.rows.updates={type:"partial",actions:{insert:[],modify:[],remove:[]},idToActionLookup:{}},S({},u,{totalRowCount:Math.max(t,u.dataRowIds.length),totalTopLevelRowCount:fe({tree:u.tree,rowCountProp:t}),groupingName:n,loading:o,groupsToFetch:i})},Oe=e=>de in e,me=e=>e.type==="skeletonRow"||e.type==="footer"||e.type==="group"&&e.isAutoGenerated||e.type==="pinnedRow"&&e.isAutoGenerated,ge=(e,t,o,r)=>{const c=e[t];if(c.type!=="group")return[];const s=[];for(let d=0;d<c.children.length;d+=1){const a=c.children[d];if((!o||!me(e[a]))&&s.push(a),r)continue;const f=ge(e,a,o,r);for(let p=0;p<f.length;p+=1)s.push(f[p])}return!o&&c.footerId!=null&&s.push(c.footerId),s},Fe=({previousCache:e,getRowId:t,updates:o,groupKeys:r})=>{if(e.updates.type==="full")throw new Error("MUI X: Unable to prepare a partial update if a full update is not applied yet.");const c=new Map;o.forEach(p=>{const n=M(p,t,"A row was provided without id when calling updateRows():");c.has(n)?c.set(n,S({},c.get(n),p)):c.set(n,p)});const s={type:"partial",actions:{insert:[...e.updates.actions.insert??[]],modify:[...e.updates.actions.modify??[]],remove:[...e.updates.actions.remove??[]]},idToActionLookup:S({},e.updates.idToActionLookup),groupKeys:r},d=S({},e.dataRowIdToModelLookup),a={insert:{},modify:{},remove:{}};c.forEach((p,n)=>{const i=s.idToActionLookup[n];if(p._action==="delete"){if(i==="remove"||!d[n])return;i!=null&&(a[i][n]=!0),s.actions.remove.push(n),delete d[n];return}const u=d[n];if(u){i==="remove"?(a.remove[n]=!0,s.actions.modify.push(n)):i==null&&s.actions.modify.push(n),d[n]=S({},u,p);return}i==="remove"?(a.remove[n]=!0,s.actions.insert.push(n)):i==null&&s.actions.insert.push(n),d[n]=p});const f=Object.keys(a);for(let p=0;p<f.length;p+=1){const n=f[p],i=a[n];Object.keys(i).length>0&&(s.actions[n]=s.actions[n].filter(u=>!i[u]))}return{dataRowIdToModelLookup:d,updates:s,rowsBeforePartialUpdates:e.rowsBeforePartialUpdates,loadingPropBeforePartialUpdates:e.loadingPropBeforePartialUpdates,rowCountPropBeforePartialUpdates:e.rowCountPropBeforePartialUpdates}},We="var(--DataGrid-overlayHeight, calc(var(--height) * 2))";function Be(e,t,o){const r=[];return t.forEach(c=>{const s=M(c,o,"A row was provided without id when calling updateRows():");if(L(e,s)?.type==="pinnedRow"){const a=e.current.caches.pinnedRows,f=a.idLookup[s];f&&(a.idLookup[s]=S({},f,c))}else r.push(c)}),r}const $e=(e,t,o)=>typeof e=="number"&&e>0?e:t,he=(e,t)=>t&&e.length>1?[e[0]]:e,qe=(e,t)=>o=>S({},o,{sorting:S({},o.sorting,{sortModel:he(e,t)})}),we=e=>e==="desc",ye=(e,t)=>{const o=t.current.getColumn(e.field);if(!o||e.sort===null)return null;let r;return o.getSortComparator?r=o.getSortComparator(e.sort):r=we(e.sort)?(...s)=>-1*o.sortComparator(...s):o.sortComparator,r?{getSortCellParams:s=>({id:s,field:o.field,rowNode:L(t,s),value:t.current.getCellValue(s,o.field),api:t.current}),comparator:r}:null},Re=(e,t,o)=>e.reduce((r,c,s)=>{if(r!==0)return r;const d=t.params[s],a=o.params[s];return r=c.comparator(d.value,a.value,d,a),r},0),Ve=(e,t)=>{const o=e.map(r=>ye(r,t)).filter(r=>!!r);return o.length===0?null:r=>r.map(c=>({node:c,params:o.map(s=>s.getSortCellParams(c.id))})).sort((c,s)=>Re(o,c,s)).map(c=>c.node.id)},Ke=(e,t)=>{const o=e.indexOf(t);return!t||o===-1||o+1===e.length?e[0]:e[o+1]},D=(e,t)=>e==null&&t!=null?-1:t==null&&e!=null?1:e==null&&t==null?0:null,ve=new Intl.Collator,Xe=(e,t)=>{const o=D(e,t);return o!==null?o:typeof e=="string"?ve.compare(e.toString(),t.toString()):e-t},He=(e,t)=>{const o=D(e,t);return o!==null?o:Number(e)-Number(t)},Je=(e,t)=>{const o=D(e,t);return o!==null?o:e>t?1:e<t?-1:0};var Se=(function(e){return e.Cell="cell",e.Row="row",e})(Se||{}),Ce=(function(e){return e.Edit="edit",e.View="view",e})(Ce||{}),Te=(function(e){return e.Edit="edit",e.View="view",e})(Te||{});export{Me as A,L as B,ze as C,_ as D,O as E,Te as F,Se as G,je as H,Be as I,Fe as J,ge as K,M as L,Ee as M,Ne as N,fe as O,Ge as P,_e as Q,De as R,Le as S,Ke as T,Ve as U,qe as V,he as W,Pe as a,w as b,ce as c,k as d,me as e,xe as f,Xe as g,He as h,Oe as i,de as j,ie as k,U as l,le as m,z as n,Je as o,ke as p,Ue as q,Ae as r,se as s,ne as t,Ie as u,ae as v,We as w,$e as x,J as y,Ce as z};
